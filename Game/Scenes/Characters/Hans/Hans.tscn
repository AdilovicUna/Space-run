[gd_scene load_steps=5 format=2]

[ext_resource path="res://Characters/Hans/Hans.gltf" type="PackedScene" id=1]
[ext_resource path="res://Characters/Hans/HansRunning.tres" type="Animation" id=2]

[sub_resource type="GDScript" id=1]
script/source = "extends KinematicBody

enum lvl {ONE, TWO, THREE}

onready var main = get_parent()
onready var ground = get_node(\"../Ground\")
onready var tunnels = get_node(\"../Tunnels\") # Tunnels
onready var tunnels_children = get_node(\"../Tunnels\").get_children() # lvl1, lvl2, lvl3
onready var score = get_node(\"../UI/Score\")
onready var end = get_node(\"../UI/End\")

#every piece of code that is changed by this line has the 
#\"TESTING\" 
#indicator above it
var TESTING = false

var rand = RandomNumberGenerator.new()

var move_tunnel = lvl.ONE
var next_tunnel = lvl.TWO
var curr_tunnel = lvl.ONE
#TESTING
var speed = 50.0 if !TESTING else 75.0
var total_translation = 1250 # original entrence to the level2 tunnel
var x = rand.randi_range(1120,1190) # first trap for the next level will be here
var new_trap = 3650 # start producing traps for the next level at this point
var difference = 2500
var deviation = 0.01

func get_current_tunnel():
    return curr_tunnel

func _physics_process(_delta):
    # making tunnels (and ground) infinite by moving them forward
    # after Hans passes them	
    var tunnel = tunnels_children[move_tunnel]
    if translation.x < tunnel.translation.x - 2000:				
        tunnel.translation.x -= 7500    # move tunnel ahead (3x2500)
        move_tunnel = (move_tunnel + 1) % tunnels_children.size()
    if translation.x < ground.translation.x - 2000:
        ground.translation.x -= 3000 # move ground ahead
    
    if translation.x < total_translation:
        # update cur_tunnel Hans is running through
        total_translation -= 2500
        next_tunnel = (next_tunnel + 1) % tunnels_children.size()
        curr_tunnel = (curr_tunnel + 1) % tunnels_children.size()
        
        rand.randomize()
        # restart x
        x = rand.randi_range(1120,1190)
        
        difference -= 2500
    
    tunnels.delete_obstacle_until_x(curr_tunnel,translation.x - difference + 50)
    
    # create a trap in the next tunnel every 50 meters
    if translation.x < new_trap:
        new_trap -= 50
        if x > -1200:
            tunnels.create_one_obstacle(next_tunnel,x)
        
        # FINAL
        # UNCOMMENT AFTER IMPLEMENTING SHOOTING
        # choose a place for the next obstacle
        # NOTE: level2 and level3 have bugs and viruses, so we want less obstacles 
        # a) we need more time to shoot down a bug or a virus
        # b) bugs and viruses are longer than traps thus take more space along x-axis
        # x -= rand.randi_range(70,90) if next_tunnel == lvl.ONE else rand.randi_range(170,190)
        
        ##choose a place for the next obstacle
        ## NOTE: level2 and level3 have bugs and viruses, so we want less obstacles 
        ## bugs and viruses are longer than traps thus take more space along x-axis
        x -= rand.randi_range(70,90) if next_tunnel == lvl.ONE else rand.randi_range(120,140)
    
    
    # updating score 
    score._on_Meter_Passed()
    
    # Hans's movement
    var velocity = Vector3.LEFT * speed
    velocity = move_and_slide(velocity)
    
    # End game if Hans touches the trap
    for index in get_slide_count():
        var collision = get_slide_collision(index)	
        #TESTING
        if collision.collider is KinematicBody and !TESTING:
            main._game_over()
            return
            
    if curr_tunnel != lvl.ONE:
        bug_virus_movement()

func bug_virus_movement():
    for obstacle in tunnels_children[curr_tunnel].get_children():
        if \"Trap\" in obstacle.name or \"torus\" in obstacle.name:
            continue;
            
        var tunnel_rot = tunnels_children[curr_tunnel].rotation.x + PI
        var obstacle_rot = obstacle.rotation.x + PI
        
        if (-1) * deviation > tunnel_rot + obstacle_rot  or tunnel_rot + obstacle_rot > deviation:
        #if tunnel_rot != obstacle_rot:
            var dec = fmod(abs(obstacle_rot + tunnel_rot),2 * PI) 
            var inc = abs(2 * PI - fmod(tunnel_rot + obstacle_rot, 2* PI))
            if dec > inc:
                obstacle.rotate_x(0.01)
            else:
                obstacle.rotate_x(-0.01)                
            
"

[sub_resource type="CapsuleShape" id=2]

[node name="Hans" type="KinematicBody"]
collision_mask = 2
script = SubResource( 1 )

[node name="Pivot" type="Spatial" parent="."]

[node name="Hans" parent="Pivot" instance=ExtResource( 1 )]

[node name="Running" type="AnimationPlayer" parent="Pivot/Hans"]
autoplay = "HansRunning"
anims/HansRunning = ExtResource( 2 )

[node name="CollisionShape" type="CollisionShape" parent="."]
transform = Transform( 2.98112, 0, 0, 0, -0.07764, 4.00904, 0, -2.51225, -0.182664, 0, 6.87551, 1.04777 )
shape = SubResource( 2 )
